incurred_latest[i:(firstNonNA - 1)] <- 0
}
# Fill the rest of NAs with the prior non-NAs
incurred_latest <- zoo::na.locf(incurred_latest, na.rm = TRUE)
for (k in 1:I) {
incurred_cumulative[i, k] <- incurred_cumulative[i, k] + incurred_latest[k]
}
}
}
no_txn <- lengths(lapply(unlist(incurred_history, recursive = F), `[[`, "txn_delay"))
total_no_txn <- sum(no_txn)
if (adjustment / total_no_txn > 0.03) {
warning("More than 3% of the transactions were outside the bound.")
}
if (aggregate_level != 1) {
# if aggregate at a higher level (e.g. aggregate_level = 4 for yearly triangles)
new_side_length <- I / aggregate_level
incurred_cumulative_orig <- incurred_cumulative
incurred_cumulative <- array(0, c(new_side_length, new_side_length))
for (i in 1:new_side_length) {
side_occurrence <- (aggregate_level * (i-1) + 1): (aggregate_level * i)
for (j in 1:new_side_length) {
side_development <- aggregate_level * j
incurred_cumulative[i, j] <- sum(
incurred_cumulative_orig[side_occurrence, side_development])
}
}
}
if (incremental == TRUE) {
incurred_incremental <- incurred_cumulative
for (i in 1:dim(incurred_cumulative)[1]) {
incurred_incremental[i, 1] <- incurred_cumulative[i, 1]
for (j in 2:dim(incurred_cumulative)[2]) {
incurred_incremental[i, j] <- incurred_cumulative[i, j] - incurred_cumulative[i, j - 1]
}
}
incurred_incremental
} else {
incurred_cumulative
}
}
x <- incurred_output(test_inflated)
# new
y <- output_incurred(test_inflated)
View(x)
View(y)
View(x)
View(y)
View(x)
View(x)
sum(x)
sum(y)
incurred_latest
incurred_latest[i_rescaled:(firstNonNA - 1)] <- 0
# Fill the rest of NAs with the prior non-NAs
incurred_latest <- zoo::na.locf(incurred_latest, na.rm = TRUE)
incurred_latest
incurred_inflated_yr <- output_incurred(test_inflated, incremental = TRUE,
future = FALSE)
View(incurred_inflated, incurred_inflated_yr)
View(incurred_inflated)
View(incurred_inflated_yr)
# Inflated INCREMENTAL triangle
incurred_inflated <- output_incurred(test_inflated, incremental = TRUE)
incurred_inflated_yr <- output_incurred(test_inflated, incremental = TRUE,
future = FALSE)
incurred_inflated_yr <- output_incurred(test_inflated, incremental = TRUE,
aggregate_level = 4)
View(incurred_inflated_yr)
# Inflated CUMULATIVE triangle
incurred_inflated <- output_incurred(test_inflated, incremental = FALSE)
incurred_inflated_yr <- output_incurred(test_inflated, incremental = FALSE,
aggregate_level = 4)
# Inflated CUMULATIVE triangle
incurred_inflated <- output_incurred(test_inflated, incremental = FALSE)
View(incurred_inflated)
View(incurred_inflated)
View(incurred_inflated_yr)
sum(incurred_inflated[, 40])
sum(incurred_inflated_yr[, 10])
sum(test_incurred_dataset_inflated$incurred)
# Inflated CUMULATIVE triangle
incremental <- output_incurred(test_inflated, incremental = TRUE)
rowsum(incremental)
rowSums(incremental)
# Inflated CUMULATIVE triangle
incremental <- output_incurred(test_inflated, incremental = TRUE, aggregate_level = F)
# Inflated CUMULATIVE triangle
incremental <- output_incurred(test_inflated, incremental = TRUE, aggregate_level = 4)
rowSums(incremental)
document()
?claim_maRev_no
?sample
breakpoints
x <- function() {1}
x
x()
mapply(x)
x <- function() {c(prob = 0.5)}
mapply(x)
mapply(x, prob = 2)
do.call(rbind, as.list(x = c(1,2,3)))
do.call(rbind, as.list(x = c(1,2,3), y = c(2,3,4)))
do.call(rbind, as.list("x" = c(1,2,3), "y" = c(2,3,4)))
args <- as.list("x" = 1:3, "y" = 4:6)
args
args <- list("x" = 1:3, "y" = 4:6)
args
as.list(args)
do.call(rbind, as.list(args))
args <- list("x" = 1:3)
do.call(rbind, as.list(args))
minor[[1]][[1]]
minor_orig <- minor
load_all()
minor_orig[[40]][[100]]
minor_orig[[40]][[85]]
minor_orig[[40]][[84]]
######## Testing Code
set.seed(20201006)
test_claims <- SynthETIC::test_claims_object
## With SPLICE loaded (locally)
major <- claim_maRev_no(test_claims)
major <- claim_maRev_time(test_claims, major)
major <- claim_maRev_size(major)
# minor revisions
minor <- claim_miRev_no(test_claims)
load_all()
######## Testing Code
set.seed(20201006)
test_claims <- SynthETIC::test_claims_object
## With SPLICE loaded (locally)
major <- claim_maRev_no(test_claims)
major <- claim_maRev_time(test_claims, major)
major <- claim_maRev_size(major)
# minor revisions
minor <- claim_miRev_no(test_claims)
load_all()
# minor revisions
minor <- claim_miRev_no(test_claims)
# function to simulate the number of minor revisions
# ... that coincide with a payment
rfun_atP <- function(n, prob) {
# n = number of payments
rev_atP <- sample(c(0, 1), size = n, replace = TRUE, prob = prob)
# return the revision at payment indicators
rev_atP
}
rfun_NatP <- function(n, setldel) {
# n = number of observations/claims
k2 <- stats::rgeom(n, prob = 1 / (min(3, setldel/4) + 1))
k2
}
# the default rfun directly takes setldel as an input, so the "empty"
# paramfun would do the trick
paramfun_NatP <- function(...) {
c(...)
}
I <- length(frequency_vector)
miRev <- vector("list", I)
# miRev_unit stores all minor revision information on a single claim
miRev_unit <- list(
miRev_atP = NA,
miRev_no_atP = NA, miRev_no_NatP = NA,
miRev_time_atP = NA, miRev_time_NatP = NA,
miRev_multiplier_atP = NA, miRev_multiplier_NatP = NA
)
# function to simulate the number of minor revisions
# ... that coincide with a payment
rfun_atP <- function(n, prob) {
# n = number of payments
rev_atP <- sample(c(0, 1), size = n, replace = TRUE, prob = prob)
# return the revision at payment indicators
rev_atP
}
rfun_NatP <- function(n, setldel) {
# n = number of observations/claims
k2 <- stats::rgeom(n, prob = 1 / (min(3, setldel/4) + 1))
k2
}
# the default rfun directly takes setldel as an input, so the "empty"
# paramfun would do the trick
paramfun_NatP <- function(...) {
c(...)
}
I <- length(frequency_vector)
miRev <- vector("list", I)
# miRev_unit stores all minor revision information on a single claim
miRev_unit <- list(
miRev_atP = NA,
miRev_no_atP = NA, miRev_no_NatP = NA,
miRev_time_atP = NA, miRev_time_NatP = NA,
miRev_multiplier_atP = NA, miRev_multiplier_NatP = NA
)
params <- mapply(paramfun_NatP,
setldel = unlist(settlement_list, use.names = FALSE))
# convert to function arguments
# if params only has one parameter, asplit() won't work
if (!is.null(names(params))) {
params_split <- split(unname(params), names(params))
} else if (length(params)) {
params_split <- asplit(params, 1)
}
# do.call rfun_NatP, but ignore unused arguments
args <- as.list(params_split)
keep_names <- c(intersect(names(args), names(formals(rfun_NatP))))
keep_formals <- c(args[keep_names])
# turn keep_formals, which is a list of arguments, to a dataframe
args_df <- do.call(rbind, keep_formals)
curr <- 1
for (i in 1:I) {
miRev[[i]] <- vector("list", frequency_vector[i])
for (j in 1:frequency_vector[i]) {
miRev[[i]][[j]] <- miRev_unit
# miRev simultaneous with a payment
miRev[[i]][[j]]$miRev_atP <- rfun_atP(
n = no_payments_list[[i]][j], prob = prob_atP)
miRev[[i]][[j]]$miRev_no_atP <- sum(miRev[[i]][[j]]$miRev_atP)
# miRev non-simultaneous with a payment
if (paramfun_filled) {
tt <- try(miRev[[i]][[j]]$miRev_no_NatP <- do.call(
rfun_NatP, c(as.list(args_df[, curr]), n = 1)))
if (methods::is(tt, "try-error")) {
stop("need to specify 'paramfun_NatP' for the sampling distribution")
}
} else {
miRev[[i]][[j]]$miRev_no_NatP <- do.call(
rfun_NatP, c(as.list(args_df[, curr]), n = 1))
}
curr <- curr + 1
}
}
prob_atP <- 0.5
i
j
miRev[[i]][[j]] <- miRev_unit
# miRev simultaneous with a payment
miRev[[i]][[j]]$miRev_atP <- rfun_atP(
n = no_payments_list[[i]][j], prob = prob_atP)
no_payments_list[[i]][j]
rfun_atP(6, prob = 0.5)
sample(c(0, 1), size = 6, replace = TRUE, prob = 0.5)
?sample
sample(c(0, 1), size = 6, replace = TRUE, prob = rep(0.5, 6))
rep(0.5, 6)
load_all()
######## Testing Code
set.seed(20201006)
test_claims <- SynthETIC::test_claims_object
## With SPLICE loaded (locally)
major <- claim_maRev_no(test_claims)
major <- claim_maRev_time(test_claims, major)
major <- claim_maRev_size(major)
# minor revisions
minor <- claim_miRev_no(test_claims)
minor <- claim_miRev_time(test_claims, minor)
minor <- claim_miRev_size(test_claims, major, minor)
minor[[1]][[1]]
major[[1]][[29]]
# the paramfun needs to account for the "computation" of penultimate_delay
# from the payment_delay_list
paramfun <- function(payment_delays, ...) {
c(penultimate_delay = sum(payment_delays[1:length(payment_delays)-1]),
...)
}
params <- mapply(
paramfun,
claim_size = unlist(claim_size_list, use.names = FALSE),
setldel = unlist(settlement_list, use.names = FALSE),
# reduce payment_delays by one level only (to claim level)
payment_delays = unlist(payment_delay_list, use.names = F, recursive = F),
...)
params <- mapply(
paramfun,
claim_size = unlist(claim_size_list, use.names = FALSE),
setldel = unlist(settlement_list, use.names = FALSE),
# reduce payment_delays by one level only (to claim level)
payment_delays = unlist(payment_delay_list, use.names = F, recursive = F))
!is.null(names(params))
length(params)
params_split <- asplit(params, 1)
rm(params_split)
# if params only has one parameter, asplit() won't work
if (!is.null(names(params))) {
params_split <- split(unname(params), names(params))
} else if (length(params)) {
params_split <- asplit(params, 1)
}
######## Testing Code
set.seed(20201006)
test_claims <- SynthETIC::test_claims_object
## With SPLICE loaded (locally)
major <- claim_maRev_no(test_claims)
major <- claim_maRev_time(test_claims, major)
major <- claim_maRev_size(major)
# minor revisions
minor <- claim_miRev_no(test_claims)
minor <- claim_miRev_time(test_claims, minor)
minor <- claim_miRev_size(test_claims, major, minor)
minor[[1]][[1]]
major[[1]][[29]]
######## Testing Code
set.seed(20201006)
test_claims <- SynthETIC::test_claims_object
## With SPLICE loaded (locally)
major <- claim_maRev_no(test_claims)
major <- claim_maRev_time(test_claims, major)
major <- claim_maRev_size(major)
major[[1]][[29]]
## generated with default assumptions
library(SynthETIC)
set.seed(20200131)
n_vector <- claim_frequency(I = 40, E = 12000, freq = 0.1)
occurrence_times <- claim_occurrence(n_vector)
claim_sizes <- claim_size(n_vector)
notidel <- claim_notification(n_vector, claim_sizes)
setldel <- claim_closure(n_vector, claim_sizes)
no_payments <- claim_payment_no(n_vector, claim_sizes)
payment_sizes <- claim_payment_size(n_vector, claim_sizes, no_payments)
payment_delays <- claim_payment_delay(n_vector, claim_sizes, no_payments, setldel)
payment_times <- claim_payment_time(n_vector, occurrence_times, notidel, payment_delays)
base_inflation_vector <- rep((1.02)^(1/4) - 1, times = 80)
payment_inflated <- claim_payment_inflation(
n_vector, payment_sizes, payment_times, occurrence_times,
claim_sizes, base_inflation_vector)
# generate datasets
# claim level data
claim_dataset <- generate_claim_dataset(
frequency_vector = n_vector,
occurrence_list = occurrence_times,
claim_size_list = claim_sizes,
notification_list = notidel,
settlement_list = setldel,
no_payments_list = no_payments
)
# payment level data
test_claims <- claims(
n_vector, occurrence_times, claim_sizes, notidel, setldel, no_payments,
payment_sizes, payment_delays, payment_times, payment_inflated)
transaction_dataset <- generate_transaction_dataset(
test_claims,
adjust = FALSE # to keep the original simulated payment times
)
write.csv(claim_dataset, "~/Downloads/claim_dataset_20210825.csv")
write.csv(transaction_dataset, "~/Downloads/payment_dataset_inflated_20210825.csv")
## With SPLICE loaded (locally)
major <- claim_maRev_no(test_claims)
library(devtools)
load_all()
## With SPLICE loaded (locally)
major <- claim_maRev_no(test_claims)
major <- claim_maRev_time(test_claims, major)
major <- claim_maRev_size(major)
# minor revisions
minor <- claim_miRev_no(test_claims)
minor <- claim_miRev_time(test_claims, minor)
minor <- claim_miRev_size(test_claims, major, minor)
test <- claim_history(test_claims, major, minor)
test_inflated <- claim_history(test_claims, major, minor, inflated = TRUE,
base_inflation_vector = rep((1 + 0.02)^(1/4) - 1, times = 80))
test_inflated <- claim_history(test_claims, major, minor,
base_inflation_vector = rep((1 + 0.02)^(1/4) - 1, times = 80))
test_incurred_dataset <- generate_incurred_dataset(test_claims, test)
test_incurred_dataset_inflated <- generate_incurred_dataset(test_claims, test_inflated)
View(test_incurred_dataset)
test[[1]][[1]]
## generated with default assumptions
library(SynthETIC)
set.seed(20200131)
n_vector <- claim_frequency(I = 40, E = 12000, freq = 0.1)
occurrence_times <- claim_occurrence(n_vector)
claim_sizes <- claim_size(n_vector)
notidel <- claim_notification(n_vector, claim_sizes)
setldel <- claim_closure(n_vector, claim_sizes)
no_payments <- claim_payment_no(n_vector, claim_sizes)
payment_sizes <- claim_payment_size(n_vector, claim_sizes, no_payments)
payment_delays <- claim_payment_delay(n_vector, claim_sizes, no_payments, setldel)
payment_times <- claim_payment_time(n_vector, occurrence_times, notidel, payment_delays)
base_inflation_vector <- rep((1.02)^(1/4) - 1, times = 80)
payment_inflated <- claim_payment_inflation(
n_vector, payment_sizes, payment_times, occurrence_times,
claim_sizes, base_inflation_vector)
# generate datasets
# claim level data
claim_dataset <- generate_claim_dataset(
frequency_vector = n_vector,
occurrence_list = occurrence_times,
claim_size_list = claim_sizes,
notification_list = notidel,
settlement_list = setldel,
no_payments_list = no_payments
)
# payment level data
test_claims <- claims(
n_vector, occurrence_times, claim_sizes, notidel, setldel, no_payments,
payment_sizes, payment_delays, payment_times, payment_inflated)
transaction_dataset <- generate_transaction_dataset(
test_claims,
adjust = FALSE # to keep the original simulated payment times
)
# write.csv(claim_dataset, "~/Downloads/claim_dataset_20210825.csv")
# write.csv(transaction_dataset, "~/Downloads/payment_dataset_inflated_20210825.csv")
# triangles
# Constant dollar value INCREMENTAL triangle
output_noinflation <- claim_output(n_vector, payment_times, payment_sizes,
incremental = TRUE)
# Inflated INCREMENTAL triangle
output_actual <- claim_output(n_vector, payment_times, payment_inflated,
incremental = TRUE)
# write.csv(output_noinflation, "~/Downloads/triangle_noInf_20210825.csv")
# write.csv(output_actual, "~/Downloads/triangle_inflated_20210825.csv")
## With SPLICE loaded (locally)
major <- claim_maRev_no(test_claims)
major <- claim_maRev_time(test_claims, major)
major <- claim_maRev_size(major)
# minor revisions
minor <- claim_miRev_no(test_claims)
minor <- claim_miRev_time(test_claims, minor)
minor <- claim_miRev_size(test_claims, major, minor)
test <- claim_history(test_claims, major, minor)
test_inflated <- claim_history(test_claims, major, minor,
base_inflation_vector = rep((1 + 0.02)^(1/4) - 1, times = 80))
test_incurred_dataset <- generate_incurred_dataset(test_claims, test)
test_incurred_dataset_inflated <- generate_incurred_dataset(test_claims, test_inflated)
major[[1]][[1]]
View(test_incurred_dataset_inflated)
View(test_incurred_dataset)
View(transaction_dataset)
write.csv(test_incurred_dataset, "~/Downloads/incurred_dataset_noInf_20210825.csv")
write.csv(test_incurred_dataset_inflated, "~/Downloads/incurred_dataset_inflated_20210825.csv")
write.csv(incurred_noInf, "~/Downloads/incurred_triangle_noInf_20210825.csv")
# incurred triangles
# Constant dollar value INCREMENTAL triangle
incurred_noInf <- output_incurred(test, incremental = TRUE)
# Inflated INCREMENTAL triangle
incurred_inflated <- output_incurred(test_inflated, incremental = TRUE)
write.csv(incurred_noInf, "~/Downloads/incurred_triangle_noInf_20210825.csv")
write.csv(incurred_inflated, "~/Downloads/incurred_triangle_inflated_20210825.csv")
x <- claim_dataset %>%
select(claim_no, occurrence_time) %>%
merge(test_incurred_dataset, by = "claim_no")
library(dplyr)
i
x <- claim_dataset %>%
select(claim_no, occurrence_time) %>%
merge(test_incurred_dataset, by = "claim_no")
View(x)
test_incurred_dataset <- generate_incurred_dataset(test_claims, test)
colnames(test_incurred_dataset)
occurrence <- data.frame(
claim_no = claim_dataset$claim_no,
claim_size = claim_dataset$claim_size,
txn_time = claim_dataset$occurrence_time,
txn_delay = -claim_dataset$notidel,
txn_type = "O",
incurred = 0,
OCL = 0,
cumpaid = 0,
multiplier = NA)
View(occurrence)
x <- rbind(test_incurred_dataset, occurrence) %>%
arrange(claim_no, txn_time)
View(x)
nrow(x)
nrow(test_incurred_dataset) + nrow(claim_dataset)
1.7948353 - 0.6238351
2.5837741 - 0.1206679
y <- rbind(test_incurred_dataset_inflated, occurrence) %>%
arrange(claim_no, txn_time)
write.csv(x, "~/Downloads/incurred_dataset_noInf_20210825.csv")
write.csv(y, "~/Downloads/incurred_dataset_inflated_20210825.csv")
# incurred triangles
# Constant dollar value INCREMENTAL triangle
incurred_noInf <- output_incurred(test, incremental = TRUE)
# Inflated INCREMENTAL triangle
incurred_inflated <- output_incurred(test_inflated, incremental = TRUE)
write.csv(incurred_noInf, "~/Downloads/incurred_triangle_noInf_20210825.csv")
write.csv(incurred_inflated, "~/Downloads/incurred_triangle_inflated_20210825.csv")
library(devtools)
load_all()
document()
?claim_majRev_no
document()
?claim_minRev
load_all()
document()
document()
?claim_minRev_no
?incurred_history
?claim_history
?claim_minRev_no
document()
?claim_minRev_no
?claim_minRev_freq
?test_incurred_dataset
?claim_history
?claim_minRev_freq
document()
?devtools::check_win
check_win_oldrelease("../../SPLICE_1.0.0.tar.gz")
check_win_oldrelease(pkg = "../../SPLICE_1.0.0.tar.gz")
check_win_oldrelease("~/Dropbox/2020/Summer Research/Claims Simulator/Simulator Code/Repo/SPLICE_1.0.0.tar.gz")
check_win_oldrelease(pkg = as.package("../../SPLICE_1.0.0.tar.gz"))
check_win_oldrelease(pkg = "SPLICE")
check_win_oldrelease(pkg = SPLICE)
check_win_oldrelease(pkg = as.package(SPLICE))
load_all()
install.packages("rhub")
library(rhub)
validate_email()
check("../../SPLICE_1.0.0.tar.gz")
check("../../SPLICE_1.0.0.tar.gz")
